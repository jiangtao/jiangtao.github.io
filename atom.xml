<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江涛</title>
  
  <subtitle>记录成长，共同进步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imjiangtao.com/"/>
  <updated>2019-11-15T06:10:25.903Z</updated>
  <id>https://imjiangtao.com/</id>
  
  <author>
    <name>f2ecoder@vip.qq.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建一个通用的脚手架</title>
    <link href="https://imjiangtao.com/2018/01/29/project-next-cli/"/>
    <id>https://imjiangtao.com/2018/01/29/project-next-cli/</id>
    <published>2018-01-29T19:53:36.000Z</published>
    <updated>2019-11-15T06:10:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>在16年年底的时候，同事聊起脚手架。由于公司业务的<code>多样性</code>,前端的<code>灵活性</code>,让我们不得不思考更通用的脚手架。而不是伴随着前端技术的发展，不断的把时间花在<code>配置</code>上。于是<a href="https://github.com/2046/chef-cli" target="_blank" rel="noopener">chef-cli</a>诞生了。 18年年初，把过往一年的东西整理和总结下，重新增强了原有的脚手架<a href="https://github.com/ijs/project-next-cli" target="_blank" rel="noopener">project-next-cli</a>, 不单单满足我们团队的需求，也可以满足其他人的需求。</p><a id="more"></a><h2 id="project-next-cli"><a href="#project-next-cli" class="headerlink" title="project-next-cli"></a>project-next-cli</h2><p>面向的目标用户：</p><ul><li>公司业务杂，但有一定的积累</li><li>爱折腾的同学和团队</li><li>借助github大量开发模板开发</li></ul><p><img src="https://github.com/ijs/project-next-cli/raw/master/project-next-cli.gif" alt="image"></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>从本人做前端开始（13年），前端这几年处于高速发展，主要表现：</p><p>备注：以下发展过程出现，请不要纠结出现顺序 [捂脸]</p><ul><li>库/框架：jQuery, backbone， angular，react，vue</li><li>模块化：commonjs， AMD(CMD), UMD, es module</li><li>任务管理器：npm scripts,  grunt, gulp</li><li>模块打包工具： r.js, webpack, rollup, browserify</li><li>css预处理器：Sass, Less, Stylus, Postcss</li><li>静态检查器：flow/typescript</li><li>测试工具：mocha，jasmine，jest，ava</li><li>代码检测工具：eslint，jslint</li></ul><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>当我们真实开发中，会遇到各种各样的业务需求（场景），根据需求和场景选用不同的技术栈，由于技术的进步和不同浏览器运行时的限制，不得不配置对应的环境等，导致我们从而满足业务需求。</p><p>画了一张图来表示，业务，配置（环境），技术之间的关系</p><p><img src="/images/dev.jpg" alt="image"></p><h3 id="前端配置工程师"><a href="#前端配置工程师" class="headerlink" title="前端配置工程师"></a>前端配置工程师</h3><p>于是明见流传了一个新的职业，前端配置工程师 O(∩_∩)O~</p><h2 id="社区现状"><a href="#社区现状" class="headerlink" title="社区现状"></a>社区现状</h2><h3 id="专一的脚手架"><a href="#专一的脚手架" class="headerlink" title="专一的脚手架"></a>专一的脚手架</h3><p>社区中存在着大量的专一型框架，主要针对一个目标任务做定制。比如下列脚手架</p><ol><li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli</a></li></ol><p><code>vue-cli</code>提供利用vue开发<code>webpack</code>, <code>pwa</code>等模板，本文脚手架参考了<code>vue-cli</code>的实现。</p><ol><li><a href="https://github.com/dvajs/dva-cli" target="_blank" rel="noopener">dva-cli</a></li></ol><p><code>dva-cli</code>主要针对<a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a>开发使用的脚手架</p><ol><li><a href="https://github.com/maichong/labrador" target="_blank" rel="noopener">labrador</a></li></ol><p><code>labrador</code>是一种<code>微信小程序</code>组件化开发框架, 虽说小程序目前已经支持组件，但该脚手架的其他特性，依旧很赞。感兴趣的可以了解。</p><p>社区中有很多优秀的专一型脚手架出现，这里不在列举。前端社区的火爆，让我辈前端汲取精华，不断前进。</p><h3 id="通用脚手架"><a href="#通用脚手架" class="headerlink" title="通用脚手架"></a>通用脚手架</h3><ol><li><a href="https://github.com/yeoman/yeoman" target="_blank" rel="noopener">yeoman</a></li></ol><p><code>yeoman</code>是一款强壮的且有一系列工具的通用型脚手架，但yeoman发布指定package名称，和用其开发工具。具体可<a href="http://yeoman.io/generators/" target="_blank" rel="noopener">点击这里查看yeoman添加生成器规则</a></p><h2 id="开发初衷和目标"><a href="#开发初衷和目标" class="headerlink" title="开发初衷和目标"></a>开发初衷和目标</h2><p>由于金融公司形态决定了，业务类型多样，前端技术发展迭代，为了跟进社区发展，更好的完成下列目标而诞生。</p><ul><li>完成业务：专心，稳定，快速</li><li>团队规范：代码规范，发布流程，持续集成/交付/部署</li><li>沉淀：持续稳定的引入新技术</li><li>效益：少加班，少造轮子，完成kpi，做更有意义的事儿</li></ul><h2 id="实现准备"><a href="#实现准备" class="headerlink" title="实现准备"></a>实现准备</h2><p>依托于Github，根据<code>Github API</code>来实现，如下：</p><ol><li>获取项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://api.github.com/orgs/project-scaffold/repos</span><br></pre></td></tr></table></figure><ol><li>获取版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://api.github.com/repos/project-scaffold/cli/tags</span><br></pre></td></tr></table></figure><h2 id="具体实现逻辑"><a href="#具体实现逻辑" class="headerlink" title="具体实现逻辑"></a>具体实现逻辑</h2><p>根据<code>github api</code>获取到项目列表和版本号之后，根据输入的名称，选择对应的版本下载到本地<code>私有仓库</code>，生成到执行目录下。详情流程图如下：。</p><p><img src="/images/project-flow.png" alt="image"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li>使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project i</span><br></pre></td></tr></table></figure><ol><li>逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Github API ===&gt; 获取项目列表 ===&gt; 选择一个项目 ===&gt; 获取项目版本号 ===&gt; 选择一个版本号 ===&gt; 下载到本地仓库</span><br></pre></td></tr></table></figure><p>若中间每一步 数据为空/文件不存在 则给予提示</p><ol><li>核心代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取github项目列表</span></span><br><span class="line"><span class="keyword">const</span> repos = <span class="keyword">await</span> repoList();</span><br><span class="line"></span><br><span class="line">choices = repos.map(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> name);</span><br><span class="line">answers = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">  &#123;</span><br><span class="line">    type   : <span class="string">'list'</span>,</span><br><span class="line">    name   : <span class="string">'repo'</span>,</span><br><span class="line">    message: <span class="string">'which repo do you want to install?'</span>,</span><br><span class="line">    choices</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 选择的项目</span></span><br><span class="line"><span class="keyword">const</span> repo = answers.repo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目的版本号劣币爱哦</span></span><br><span class="line"><span class="keyword">const</span> tags = <span class="keyword">await</span> tagList(repo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tags.length === <span class="number">0</span>) &#123;</span><br><span class="line">  version = <span class="string">''</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  choices = tags.map(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> name);</span><br><span class="line"></span><br><span class="line">  answers = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">      type   : <span class="string">'list'</span>,</span><br><span class="line">      name   : <span class="string">'version'</span>,</span><br><span class="line">      message: <span class="string">'which version do you want to install?'</span>,</span><br><span class="line">      choices</span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  version = answers.version;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下载</span></span><br><span class="line"><span class="keyword">await</span> download([repo, version].join(<span class="string">'@'</span>));</span><br></pre></td></tr></table></figure><h3 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h3><ol><li>使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project init</span><br></pre></td></tr></table></figure><ol><li>逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取本地仓库列表 ===&gt; 选择一个本地项目 ===&gt; 输入基本信息 ===&gt; 编译生成到临时文件 ===&gt; 复制并重名到目标目录</span><br></pre></td></tr></table></figure><p>若中间每一步 数据为空/文件不存在/生成目录已重复 则给予提示</p><ol><li>核心代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取本地仓库项目</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">await</span> readdir(dirs.download);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本信息</span></span><br><span class="line"><span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">  &#123;</span><br><span class="line">    type   : <span class="string">'list'</span>,</span><br><span class="line">    name   : <span class="string">'scaffold'</span>,</span><br><span class="line">    message: <span class="string">'which scaffold do you want to init?'</span>,</span><br><span class="line">    choices: list</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    type   : <span class="string">'input'</span>,</span><br><span class="line">    name   : <span class="string">'dir'</span>,</span><br><span class="line">    message: <span class="string">'project name'</span>,</span><br><span class="line">    <span class="comment">// 必要的验证</span></span><br><span class="line">    <span class="keyword">async</span> validate(input) &#123;</span><br><span class="line">      <span class="keyword">const</span> done = <span class="keyword">this</span>.async();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (input.length === <span class="number">0</span>) &#123;</span><br><span class="line">        done(<span class="string">'You must input project name'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> dir = resolve(process.cwd(), input);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> exists(dir)) &#123;</span><br><span class="line">        done(<span class="string">'The project name is already existed. Please change another name'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      done(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> metalsmith = <span class="keyword">await</span> rc(<span class="string">'metalsmith'</span>);</span><br><span class="line"><span class="keyword">if</span> (metalsmith) &#123;</span><br><span class="line">  <span class="keyword">const</span> tmp = <span class="string">`<span class="subst">$&#123;dirs.tmp&#125;</span>/<span class="subst">$&#123;answers.scaffold&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 复制一份到临时目录，在临时目录编译生成</span></span><br><span class="line">  <span class="keyword">await</span> copy(<span class="string">`<span class="subst">$&#123;dirs.download&#125;</span>/<span class="subst">$&#123;answers.scaffold&#125;</span>`</span>, tmp);</span><br><span class="line">  <span class="keyword">await</span> metal(answers.scaffold);</span><br><span class="line">  <span class="keyword">await</span> copy(<span class="string">`<span class="subst">$&#123;tmp&#125;</span>/<span class="subst">$&#123;dirs.metalsmith&#125;</span>`</span>, answers.dir);</span><br><span class="line">  <span class="comment">// 删除临时目录</span></span><br><span class="line">  <span class="keyword">await</span> rmfr(tmp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> copy(<span class="string">`<span class="subst">$&#123;dirs.download&#125;</span>/<span class="subst">$&#123;answers.scaffold&#125;</span>`</span>, answers.dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="升级-降级版本"><a href="#升级-降级版本" class="headerlink" title="升级/降级版本"></a>升级/降级版本</h3><ol><li>使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project update</span><br></pre></td></tr></table></figure><ol><li>逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取本地仓库列表 ===&gt; 选择一个本地项目 ===&gt; 获取版本信息列表 ===&gt; 选择一个版本 ===&gt; 覆盖原有的版本文件</span><br></pre></td></tr></table></figure><p>若中间每一步 数据为空/文件不存在 则给予提示</p><ol><li>核心代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取本地仓库列表</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">await</span> readdir(dirs.download);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择一个要升级的项目</span></span><br><span class="line">answers = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">  &#123;</span><br><span class="line">    type   : <span class="string">'list'</span>,</span><br><span class="line">    name   : <span class="string">'scaffold'</span>,</span><br><span class="line">    message: <span class="string">'which scaffold do you want to update?'</span>,</span><br><span class="line">    choices: list,</span><br><span class="line">    <span class="keyword">async</span> validate(input) &#123;</span><br><span class="line">      <span class="keyword">const</span> done = <span class="keyword">this</span>.async();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (input.length === <span class="number">0</span>) &#123;</span><br><span class="line">        done(<span class="string">'You must choice one scaffold to update the version. If not update, Ctrl+C'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      done(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> repo = answers.scaffold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该项目的版本信息</span></span><br><span class="line"><span class="keyword">const</span> tags = <span class="keyword">await</span> tagList(repo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tags.length === <span class="number">0</span>) &#123;</span><br><span class="line">  version = <span class="string">''</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  choices = tags.map(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> name);</span><br><span class="line"></span><br><span class="line">  answers = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">      type   : <span class="string">'list'</span>,</span><br><span class="line">      name   : <span class="string">'version'</span>,</span><br><span class="line">      message: <span class="string">'which version do you want to install?'</span>,</span><br><span class="line">      choices</span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  version = answers.version;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下载覆盖文件</span></span><br><span class="line"><span class="keyword">await</span> download([repo, version].join(<span class="string">'@'</span>))</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置用来获取脚手架的基本设置， 如registry, type等基本信息。</p><ol><li>使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project config <span class="built_in">set</span> registry koajs <span class="comment"># 设置本地仓库下载源</span></span><br><span class="line"></span><br><span class="line">project config get registry <span class="comment"># 获取本地仓库设置的属性</span></span><br><span class="line"></span><br><span class="line">project config delete registry <span class="comment"># 删除本地设置的属性</span></span><br></pre></td></tr></table></figure><ol><li>逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判定本地设置文件存在 ===&gt; 读/写</span><br></pre></td></tr></table></figure><p>若中间每一步 数据为空/文件不存在 则给予提示</p><ol><li>核心代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'get'</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">await</span> rc(k));</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'set'</span>:</span><br><span class="line">      <span class="keyword">await</span> rc(k, v);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'remove'</span>:</span><br><span class="line">      <span class="keyword">await</span> rc(k, v, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">await</span> rc());</span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索远程的github仓库有哪些项目列表</p><ol><li>使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">project search</span><br></pre></td></tr></table></figure><ol><li>逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取github项目列表 ===&gt; 输入搜索的内容 ===&gt; 返回匹配的列表</span><br></pre></td></tr></table></figure><p>若中间每一步 数据为空 则给予提示</p><ol><li>核心代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">   &#123;</span><br><span class="line">     type   : <span class="string">'input'</span>,</span><br><span class="line">     name   : <span class="string">'search'</span>,</span><br><span class="line">     message: <span class="string">'search repo'</span></span><br><span class="line">   &#125;</span><br><span class="line"> ]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (answers.search) &#123;</span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">await</span> searchList();</span><br><span class="line"></span><br><span class="line">   list = list</span><br><span class="line">     .filter(<span class="function"><span class="params">item</span> =&gt;</span> item.name.indexOf(answers.search) &gt; <span class="number">-1</span>)</span><br><span class="line">     .map(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> name);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;answers.search&#125;</span> is not found`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(list.join(<span class="string">'\n'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是具体实现，该脚手架目前还有一些可以优化的地方：</p><ol><li>不同源，存储不同的文件</li><li>支持离线功能</li></ol><p>硬广：如果您觉得好用，欢迎star，也欢迎fork一块维护。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在16年年底的时候，同事聊起脚手架。由于公司业务的&lt;code&gt;多样性&lt;/code&gt;,前端的&lt;code&gt;灵活性&lt;/code&gt;,让我们不得不思考更通用的脚手架。而不是伴随着前端技术的发展，不断的把时间花在&lt;code&gt;配置&lt;/code&gt;上。于是&lt;a href=&quot;https://github.com/2046/chef-cli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chef-cli&lt;/a&gt;诞生了。 18年年初，把过往一年的东西整理和总结下，重新增强了原有的脚手架&lt;a href=&quot;https://github.com/ijs/project-next-cli&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;project-next-cli&lt;/a&gt;, 不单单满足我们团队的需求，也可以满足其他人的需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cli" scheme="https://imjiangtao.com/tags/cli/"/>
    
      <category term="Node" scheme="https://imjiangtao.com/tags/Node/"/>
    
      <category term="脚手架" scheme="https://imjiangtao.com/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>npm依赖版本锁定和管理</title>
    <link href="https://imjiangtao.com/2017/12/01/version-lock/"/>
    <id>https://imjiangtao.com/2017/12/01/version-lock/</id>
    <published>2017-12-01T19:55:00.000Z</published>
    <updated>2019-11-15T06:10:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>前几天测试的时候遇到个问题，测试的时候出现依赖升级问题，由于测试同学是重新换了个机子，重装了环境，导致下载过程中依赖升级。npm带来便利的时候也带一些问题。如果您觉得比较啰嗦，直接看结果。</p><p>我们的vue项目最早依赖2.1.8版本做了组件和项目，为了保证产品的稳定性，决定锁死版本。可以参考<a href="https://zhuanlan.zhihu.com/p/31442269" target="_blank" rel="noopener">这篇文章</a>，介绍了框架升级分析的方法。</p><a id="more"></a><p>如果你也是使用vue可能需要注意以下依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"vue-loader"</span>: <span class="string">"9.9.5"</span>,</span><br><span class="line"><span class="string">"vue-style-loader"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line"><span class="string">"vue"</span>: <span class="string">"2.1.8"</span>,</span><br><span class="line"><span class="string">"vue-template-compiler"</span>: <span class="string">"2.1.8"</span></span><br></pre></td></tr></table></figure><p>针对这种依赖升级解决方法：</p><ol><li>只发布编译后的文件</li></ol><p>这样测试同学就无需关心，升级依赖后再重新打包发布。</p><p>优点: 测试同学无需关注依赖安装<br>缺点: 产出目录充斥着各种版本的文件，增量存储repo越来越大</p><ol><li>不通过包管理工具，直接把 node_modules打包，测试环境解压，每次升级依赖重新发布</li></ol><p>开发直接把 <code>node_modules</code> 打成tar包, 部署的时候解压然后，再通过 <code>npm run test</code>打包测试. 一般现在一个项目一个node_modules打包后几十M（gzip之后），更新依赖之后解压。</p><p>好处： 无网络<br>坏处： 有一些c++的npm包，在不同的系统环境下是不同的，因此在osx下的<code>node_modules</code>，在<code>Ubuntu</code>失效。 好在我们的项目没有这种依赖包，所以也可以做一种方案。若有c++的包，则需要在本地装虚拟环境，如<code>vagrant</code>或<code>docker</code>跑测试对应的环境. 每当此时心里总是在想，咱还是前端开发吗[捂脸]</p><ol><li>包管理工具锁死</li></ol><p>node发展历程中出现了几种方式来做版本锁定, 以下面<code>package.json</code>为例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npm-lock"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"test dependies lock way"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"f2ecoder@vip.qq.com"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有下列命令的情况下,  查看 vue版本是 <code>2.5.9</code>, <code>npm outdate</code>没有输出，也就是最新版本。以下是三种锁定版本的方案，如果觉得文章啰嗦，可以直接查看表格比较：</p><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">npm-shrinkwrap.json</th><th style="text-align:center">package-lock.json</th><th style="text-align:center">yarn.lock</th></tr></thead><tbody><tr><td style="text-align:center">命令</td><td style="text-align:center">npm shrinkwrap</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">生成方式</td><td style="text-align:center">需要命令生成</td><td style="text-align:center">npm安装自动生成</td><td style="text-align:center">yarn安装自动生成</td></tr><tr><td style="text-align:center">npm版本</td><td style="text-align:center">任意</td><td style="text-align:center">&gt;=5.0.0</td><td style="text-align:center">任意</td></tr><tr><td style="text-align:center">额外安装</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">yarn</td></tr><tr><td style="text-align:center">增加依赖</td><td style="text-align:center">npm i -S vue@2.1.8 &amp;&amp; npm shrinkwrap</td><td style="text-align:center">npm i -S vue@2.1.8</td><td style="text-align:center">yarn add vue@2.1.8</td></tr><tr><td style="text-align:center">更新</td><td style="text-align:center">npm uni -S vue &amp;&amp; npm I -S vue@2.5.1</td><td style="text-align:center">npm uni -S vue&amp;&amp; npm i -S vue@2.5.1</td><td style="text-align:center">yarn upgrade vue@2.5.1</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">npm uni -S vue</td><td style="text-align:center">npm uni -S vue</td><td style="text-align:center">yarn remove vue</td></tr><tr><td style="text-align:center">发布</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">离线</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr></tbody></table><h2 id="npm-shrinkwrap"><a href="#npm-shrinkwrap" class="headerlink" title="npm shrinkwrap"></a>npm shrinkwrap</h2><p>为了确保我们使用的vue版本是2.2.0， 删除依赖，重新下载. 以下测试环境参数：</p><p>node: v6.10.2<br>npm: 3.10.10</p><p><code>npm i vue@2.2.0 -S</code>， 查看node_modules vue版本是2.2.0</p><p>npm官方提供 <code>npm shrinkwrap</code>命令，生成 <code>npm-shrinkwrap.json</code>文件。</p><p>下面对依赖做增加，删除，修改的操作，看看 <code>npm-shrinkwrap.json</code>变化</p><p><strong>1. 增加依赖</strong></p><p><code>npm  i vue-http@2.0.1 -S</code>, <code>npm-shrinkwrap.json</code> 自动将<code>vue-http</code>及其依赖添加进去</p><p><strong>2. 删除依赖</strong><br><code>npm uni vue-http -S</code>, 删除的时候自动删除<code>npm-shrinkwrap.json</code>中的<code>vue-http</code>及其依赖； 若忘了加 -S 或 -D， 则无法删除， 不够智能。</p><p><strong>3. 升级/降级依赖</strong></p><p><code>npm up vue-http@2.0.0 -S</code> ，升级依赖，依赖没有升级，<code>npm-shrinkwrap.json</code>无更新，略显鸡肋。所以更新的话，直接通过上述方式删除，再添加吧。</p><p><strong>4. 结果</strong></p><p>把node_modules删掉，<code>npm i</code>， 依赖完美下载成功。</p><p>优点：npm天然支持<br>缺点：需要手动触发，update不生效</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>重新把<code>npm shrinkwrap</code>验证逻辑跑一遍.</p><p><strong>1. 新增依赖</strong></p><p><code>yarn add vue@2.2.0 vue-http@1.0.0</code>的时候，自动生成了 <code>yarn.lock</code>文件及其相关依赖</p><p><strong>2. 删除依赖</strong></p><p><code>yarn remove vue-http</code>, 自动删除依赖</p><p><strong>3. 更新依赖</strong></p><p><code>yarn upgrade vue-http@2.0.1</code>， 依赖更新成功， <code>yarn.lock</code>版本更新成功</p><p><strong>4. 结果</strong></p><p>把node_modules删掉，<code>npm i</code>， 依赖完美下载成功。更重要的是， yarn会在本地缓存一份依赖，存储在 $HOME/.yarn-cache目录下，</p><p>存储文件的规则是： registry-package_name-version，下载前会检查缓存中是否命中，若命中直接从本地获取，因此速度更快。</p><p>优点: 通过yarn命令操作，可以自动更新yarn.lock，从缓存中读取速度快. 支持离线模式<br>缺点: 还需要在下载一个yarn命令</p><h2 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h2><p><code>package-lock.json</code>是npm 5.0之后, 对应的node版本是8.0.0, npm下载的时候会自动的出现在目录中. 将Node升级到8.0.0进行以上测试.</p><p><strong>1. 增加依赖</strong></p><p><code>npm  i vue-http@2.0.1 -S</code>, 自动生成的<code>package-lock.json</code> 自动将<code>vue-http</code>及其依赖添加进去</p><p><strong>2. 删除依赖</strong><br><code>npm uni vue-http -S</code>, 删除的时候，自动删除<code>package-lock.json</code>中的<code>vue-http</code>及其依赖； 不需要加 -S -D</p><p><strong>3. 升级/降级依赖</strong></p><p><code>npm up vue-http@2.0.0 -S</code> ，升级依赖，依赖没有升级，<code>package-lock.json</code>无更新，。所以更新的话，直接通过上述方式删除，再添加吧。是npm update的问题</p><p><strong>4. 结果</strong></p><p>把node_modules删掉，<code>npm i</code>， 依赖完美下载成功。</p><p>优点：npm天然支持， 比较智能。<br>缺点：只有npm5.0之后支持，若低于8.0.0版本的node需要手动下载npm5. 另外<code>package-lock.json</code>不能发包。 因此官方给出可以通过 <code>npm shrinkwrap</code>把 <code>package-lock.json</code>重命名为 <code>npm-shrinkwrap.json</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比总结，采用yarn管理，好处除了安装一个依赖之后，版本锁定智能，下载一次后速度快。yarn使用的包也是npm上的包可以在各个node版本中使用。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://yarnpkg.com/lang/zh-hans/docs/migrating-from-npm/" target="_blank" rel="noopener">从 npm 迁移</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天测试的时候遇到个问题，测试的时候出现依赖升级问题，由于测试同学是重新换了个机子，重装了环境，导致下载过程中依赖升级。npm带来便利的时候也带一些问题。如果您觉得比较啰嗦，直接看结果。&lt;/p&gt;
&lt;p&gt;我们的vue项目最早依赖2.1.8版本做了组件和项目，为了保证产品的稳定性，决定锁死版本。可以参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31442269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;，介绍了框架升级分析的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="npm" scheme="https://imjiangtao.com/tags/npm/"/>
    
      <category term="yarn" scheme="https://imjiangtao.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>从一个爬虫初识puppeteer</title>
    <link href="https://imjiangtao.com/2017/11/08/puppeteer-start/"/>
    <id>https://imjiangtao.com/2017/11/08/puppeteer-start/</id>
    <published>2017-11-08T19:55:00.000Z</published>
    <updated>2019-11-15T06:10:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间破事群讨论问题，突然提到一个新名词 <code>puppeteer</code>，于是好奇查了下干什么的。于是一发不可收拾。</p><a id="more"></a><h2 id="什么是puppeteer"><a href="#什么是puppeteer" class="headerlink" title="什么是puppeteer"></a>什么是puppeteer</h2><p>来自官方的介绍：</p><blockquote><p>Puppeteer是一个Node库，提供一套高度封装的API， 通过<a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">DevTools Protocol</a>来控制<a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank" rel="noopener">headless</a> Chrome</p></blockquote><h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><p>来自官方的描述：</p><blockquote><p>很多事情可以使用Puppeteer在浏览器中手工完成，下面是一些可以上手的例子：</p></blockquote><ul><li>生成屏幕快照和pdf</li><li>爬取单页面应用和预渲染内容</li><li>获取网页内容</li><li>全自动的form提交, UI测试, 键盘输入等等.</li><li>创建一个最新的，自动的测试环境。直接使用最新版本的chrome，使用最新的JavaScript和浏览器特性，跑你的测试用例</li><li>捕获你网站的<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank" rel="noopener">timeline trace</a>， 诊断性能问题</li></ul><h2 id="爬取百度图片"><a href="#爬取百度图片" class="headerlink" title="爬取百度图片"></a>爬取百度图片</h2><p>爬取特定 <strong>关键词</strong> 搜索出来的图片，百度图片分为 首页和详情页</p><h2 id="百度图片首页爬取特点"><a href="#百度图片首页爬取特点" class="headerlink" title="百度图片首页爬取特点"></a>百度图片首页爬取特点</h2><ul><li>图片一般较小，需要过滤掉小图</li><li>需要滚动加载显示更多图片，需要程序自动滚动</li></ul><h2 id="百度图片详情页爬取特点"><a href="#百度图片详情页爬取特点" class="headerlink" title="百度图片详情页爬取特点"></a>百度图片详情页爬取特点</h2><ul><li>以图片展示框展示，需要自动点击下一页</li></ul><h2 id="图片抓取通用点"><a href="#图片抓取通用点" class="headerlink" title="图片抓取通用点"></a>图片抓取通用点</h2><p>因为<code>Puppeteer</code>可以监听网络请求和响应，所以只需要在请求和响应的时候做处理即可。<br>为了保证图片尺寸，我们这里以响应时做处理。若读者需要快速的请求，不在乎小图啊，可以通过请求的时候来做处理，这样效率更快一点。</p><p>下面我们一块来撸一个百度图片的爬虫。 <strong>注：</strong> 本教程只用做演示，请大家不要搞百度呀~</p><h2 id="以首页爬取来开始Puppeteer"><a href="#以首页爬取来开始Puppeteer" class="headerlink" title="以首页爬取来开始Puppeteer"></a>以首页爬取来开始Puppeteer</h2><ol><li>首先创建 Page 实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">  headless: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line"><span class="comment">// 若需要request， 把事件改成 request 即可，但拿到的是request的信息</span></span><br><span class="line">page.on(<span class="string">'response'</span>, <span class="keyword">async</span>(data) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判定拿到的数据是否是图片， 也可以根据url规则挑选出自己想要的url</span></span><br><span class="line">  <span class="keyword">if</span> (isDownloadImageByResponse(data)) &#123;</span><br><span class="line">    <span class="comment">// 下载图片逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>自动滚动逻辑</li></ol><p>通过 <code>window.scrollBy</code> api控制滚动条自动滚动, 代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">autoScroll</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> lastScroll = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> maxScroll = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">        <span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">window</span>.scrollBy(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">          <span class="keyword">const</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">          <span class="keyword">if</span> (scrollTop === maxScroll || lastScroll === scrollTop) &#123;</span><br><span class="line">            clearInterval(interval)</span><br><span class="line">            resolve()</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastScroll = scrollTop</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err.toString())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个滚屏的爬虫逻辑就完成了，<a href="https://github.com/ijs/pcralwer" target="_blank" rel="noopener">具体的代码请查看</a>，而且不需要解析dom，也不用担心网站改版之类了，生活瞬间变得美好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Puppeteer</code>带来的是更方便的操作headless chrome, 对于前端而言，可以做更好的测试，如基本的操作测试，线上页面屏幕快照抓取和分析等等。<br>当然在很久之前也有类似的实现，比如 <code>Phantomjs</code>之流，<code>Puppeteer</code>相对而言使用浏览器最新的api，对前端而言上面更快。如果你又兴趣，不妨去利用<code>Puppeteer</code>做一些事儿。</p><p>您喜欢欢迎star or fork，转载请注明出处</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间破事群讨论问题，突然提到一个新名词 &lt;code&gt;puppeteer&lt;/code&gt;，于是好奇查了下干什么的。于是一发不可收拾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="puppeteer" scheme="https://imjiangtao.com/tags/puppeteer/"/>
    
      <category term="crawler" scheme="https://imjiangtao.com/tags/crawler/"/>
    
  </entry>
  
  <entry>
    <title>vue中的mixins实践</title>
    <link href="https://imjiangtao.com/2017/09/13/vue-mixin-apply/"/>
    <id>https://imjiangtao.com/2017/09/13/vue-mixin-apply/</id>
    <published>2017-09-13T19:55:00.000Z</published>
    <updated>2019-11-15T06:10:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>奇舞周刊推荐了一篇文章<a href="http://zcfy.cc/article/using-mixins-in-vue-js-css-tricks-3257.html" target="_blank" rel="noopener">Vue.js 中使用Mixin</a>， 用了vue大半年时间，<code>mixin</code>不知道挺惭愧。</p><p>奇舞周刊文章中已经介绍了 vue mixin。</p><ul><li>官方提示谨慎使用 <a href="http://vuejs.org/v2/guide/mixins.html#Global-Mixin" target="_blank" rel="noopener">global mixin</a></li><li>合理的场景下使用 <code>mixin</code></li></ul><p>这里再补充一个 通用业务（埋点） 来描述 mixin的优缺点。 <a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在<code>SPA</code>实现埋点需求中比较通用的需求，<code>进入页面</code> 和 <code>离开页面</code> 需要记录用户在 当前页面的 停留时间。使用<code>mixin</code>， 简化代码如下</p><p><strong>mixin.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="literal">null</span> <span class="comment">// 确保进入和离开是一个page</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendEnterPage() &#123;</span><br><span class="line">            cache = <span class="keyword">this</span>.$route</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'enter page'</span>, cache)</span><br><span class="line">        &#125;,</span><br><span class="line">        sendLeavePage() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'leave page'</span>, cache)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendEnterPage()</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">        <span class="keyword">this</span>.sendLeavePage()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>demo.vue</strong>  部分代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'mixins/test'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">text</span>: <span class="string">'Hello World'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [test],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        logic() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'do the logic about hello page'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.logic()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果图</strong></p><p><img src="https://user-images.githubusercontent.com/2155745/30382229-385a8f70-9864-11e7-8fc7-01439d8a24f2.png" alt="image"></p><p>从图中发现，使用<code>局部mixin</code> 使用 <code>mounted</code>, <code>destroyed</code> 等组件中的生成周期方法与 mixin 是 合并； 当然实验得出 methods中的方法是被覆盖的。具体是通过 <a href="https://github.com/vuejs/vue/blob/master/src/core/util/options.js" target="_blank" rel="noopener">mergeOtions function实现</a></p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>埋点这部分需求 与 核心业务 关联, 代码少，尽可能的少侵入业务。</p><h3 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h3><p><code>minxin</code>中的方法 以及实现 逻辑 其他同事不知道，不直观。 只能通过约定和沟通来解决。</p><p>以上功能有种 “修饰” 的感觉。<code>es7 decorator</code> 支持修饰模式，当局限于 类和类的方法， vue官方提供了 <a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">vue-class-component</a> 来解决这个问题。</p><p>在<code>React</code>当中已经废弃了 <code>mixin</code>，使用了 <a href="https://juejin.im/post/595243d96fb9a06bbd6f5ccd" target="_blank" rel="noopener">高阶组件</a> 来解决这个问题，其实就是支持 <code>class</code>组件，结合<code>decorator</code>来</p><p>代替mixin。 关于react理解的不对，请指出。</p><p>前端时间闲暇的时候做了一个 <a href="https://github.com/jiangtao/vue-mount-time/" target="_blank" rel="noopener">vue-mount-time</a> 用来记录，第一个组件mount开始时间到 最后一个mount组件结束时间，做了一个简单的尝试。</p><h2 id="行为统计"><a href="#行为统计" class="headerlink" title="行为统计"></a>行为统计</h2><p>若需要做行为统计，可以通过 <code>mixin</code> 拦截到所有的方法， 对方法做统一收集。根据 页面地址 +  方法名 可以 确定对应的行为，从而做到<a href="https://github.com/vue-tools/vue-analysis" target="_blank" rel="noopener">无侵入的埋点解决方案</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇是对<code>mixin</code>的看法和对业务的结合点，如有不对欢迎指正，转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;奇舞周刊推荐了一篇文章&lt;a href=&quot;http://zcfy.cc/article/using-mixins-in-vue-js-css-tricks-3257.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue.js 中使用Mixin&lt;/a&gt;， 用了vue大半年时间，&lt;code&gt;mixin&lt;/code&gt;不知道挺惭愧。&lt;/p&gt;
&lt;p&gt;奇舞周刊文章中已经介绍了 vue mixin。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方提示谨慎使用 &lt;a href=&quot;http://vuejs.org/v2/guide/mixins.html#Global-Mixin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;global mixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;合理的场景下使用 &lt;code&gt;mixin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里再补充一个 通用业务（埋点） 来描述 mixin的优缺点。
    
    </summary>
    
    
      <category term="mixin" scheme="https://imjiangtao.com/tags/mixin/"/>
    
      <category term="vue" scheme="https://imjiangtao.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>将webp接入到vue项目</title>
    <link href="https://imjiangtao.com/2017/09/13/vue-webp/"/>
    <id>https://imjiangtao.com/2017/09/13/vue-webp/</id>
    <published>2017-09-13T19:55:00.000Z</published>
    <updated>2019-11-15T06:10:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间和朋友聊天，无意间问了一个<code>vue</code>移动端项目优化。针对老的项目怎么提升更好的性能。本人这方面经验不足，忙里偷闲研究了下淘宝，聚划算等网站。</p><p>通过<code>network</code>抓包，对比分析得出几个显著的区别 <a id="more"></a></p><h2 id="调研结果"><a href="#调研结果" class="headerlink" title="调研结果"></a>调研结果</h2><ul><li>支持webp，优先使用webp</li><li>滚动加载图片</li><li>资源离线存储</li></ul><h2 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h2><p>腾讯isux写了篇文章介绍webp，感兴趣同学可以<a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="noopener">查阅</a>， 总体来说，<br>同等质量的图片webp较小. 那么，如何接入webp到vue项目中。</p><h3 id="接入webp，得先有webp"><a href="#接入webp，得先有webp" class="headerlink" title="接入webp，得先有webp"></a>接入webp，得先有webp</h3><p>生成webp的几种方式：</p><h4 id="本地生成webp，上传到cdn"><a href="#本地生成webp，上传到cdn" class="headerlink" title="本地生成webp，上传到cdn"></a>本地生成webp，上传到cdn</h4><p>google提供了 <code>CWebp</code> 工具，方便开发者使用。<br>在现在的vue/react项目中， 以<code>webpack</code>做构建的项目居多，为了更方便的在webpack构建中接入webp，一个叫 <a href="https://github.com/jiangtao/webp-webpack-plugin" target="_blank" rel="noopener">webp-webpack-plugin</a> 的插件诞生，感兴趣可以查阅源码。 该插件生成webp为：<strong>编译后的图.webp</strong> ， 如<br><code>vue.e3e41b1.jpg</code> ， <code>vue.e3e41b1.jpg.webp</code>。 将生成后的图片上传到cdn即可</p><h4 id="cdn支持"><a href="#cdn支持" class="headerlink" title="cdn支持"></a>cdn支持</h4><p>cdn支持webp。图片上传到cdn之后，直接通过url规则访问图片即可得到webp</p><h4 id="通过service-worker支持"><a href="#通过service-worker支持" class="headerlink" title="通过service worker支持"></a>通过service worker支持</h4><p>使用service worker拦截请求，改变图片的<code>content-type</code>为webp，使用浏览器对webp天然压缩做支持。 <a href="https://ppt.baomitu.com/" target="_blank" rel="noopener">声享</a> 是通过这种方式实现的。</p><h3 id="滚动加载图片"><a href="#滚动加载图片" class="headerlink" title="滚动加载图片"></a>滚动加载图片</h3><p>当我们有了原图和webp地址后，可以做进一步优化。滚动条<strong>滚动到可视区域内显示图片</strong> 。考虑到要做 <strong>webp的兼容方案</strong>，需要“动态”处理，在vue自定义一个 <code>Image</code> 重写现有的img功能，支持以下功能：</p><ol><li><p>根据webp支持程度，引用对应的图片</p></li><li><p>支持lazyload</p></li></ol><p>于是封装了vue image组件<a href="https://github.com/vue-tools/vt-image" target="_blank" rel="noopener">vt-image</a>， 旨在提升图片的性能。感兴趣可以查阅源码. 点击可查看<a href="https://vue-tools.github.io/vt-image/#/demo" target="_blank" rel="noopener">Demo</a></p><p>通过js判定支持webp：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectWebp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas, supportCanvas</span><br><span class="line"></span><br><span class="line">    canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">    supportCanvas = canvas.getContext &amp;&amp; canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportCanvas) &#123;</span><br><span class="line">        canvas.width = canvas.height = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> canvas.toDataURL(<span class="string">'image/webp'</span>, <span class="number">0.01</span>).indexOf(<span class="string">'image/webp'</span>) != <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源离线存储"><a href="#资源离线存储" class="headerlink" title="资源离线存储"></a>资源离线存储</h3><p><strong>使用 localStorage 做离线方案</strong></p><p>关于localStorage的可以查看<a href="https://www.zhihu.com/question/28467444" target="_blank" rel="noopener">知乎这篇讨论</a>，详细说明了利弊</p><p><strong>使用 service worker 做离线方案</strong></p><p>webpack插件<a href="https://github.com/NekR/offline-plugin" target="_blank" rel="noopener">offline-plugin</a>， 对webpack打包的资源做了service worker和AppCache以及兼容方案。</p><p>另外一个<a href="https://github.com/oliviertassinari/serviceworker-webpack-plugin" target="_blank" rel="noopener">serviceworker-webpack-plugin</a>只处理<code>service worker</code>，<code>sw.js</code>也是自己处理，自定义和扩展比较方便。可以从<code>chrome network</code>查看效果：<a href="https://vue-tools.github.io/vt-image/#/demo" target="_blank" rel="noopener">Demo</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>问题和过程往往比结论更重要，站在巨人的肩膀上，吸收优点引用到自己的项目。如果没有符合需求的，根据 <code>场景</code>，考虑<code>成本</code>，<code>收益</code>，要么换条路走，要么就造个吧。</p><p>如果您觉得 <a href="https://github.com/jiangtao/webp-webpack-plugin" target="_blank" rel="noopener">webp-webpack-plugin</a> 和 <a href="https://github.com/vue-tools/vt-image" target="_blank" rel="noopener">vt-image</a> 对您有用，star 和 提issue 将是对作者最好的鼓励。</p><p>感谢您花了宝贵的时间阅读，如有错误，欢迎指正。</p><p>转载请注明出处，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间和朋友聊天，无意间问了一个&lt;code&gt;vue&lt;/code&gt;移动端项目优化。针对老的项目怎么提升更好的性能。本人这方面经验不足，忙里偷闲研究了下淘宝，聚划算等网站。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;network&lt;/code&gt;抓包，对比分析得出几个显著的区别
    
    </summary>
    
    
      <category term="vue" scheme="https://imjiangtao.com/tags/vue/"/>
    
      <category term="webp" scheme="https://imjiangtao.com/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>xss live学习总结</title>
    <link href="https://imjiangtao.com/2017/09/13/xss-live/"/>
    <id>https://imjiangtao.com/2017/09/13/xss-live/</id>
    <published>2017-09-13T19:55:00.000Z</published>
    <updated>2019-11-15T06:10:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>朋友组织了一场<code>xss</code> live，<code>安全</code>一直是开发中不可忽视的一部分。而<code>xss</code>作为web开发中最常见的攻击手段，防范是必然的。基于<strong>web浏览器tricks</strong>，<strong>JavaScript的发展</strong>，<strong>npm等开源项目漏洞</strong>，<strong>web注入</strong>等会让开发者越来越防不胜防。</p><p>本次总结基于耗子的<a href="https://github.com/haozime/xss-demo" target="_blank" rel="noopener">xss-demo</a>，以及自己对xss的理解和知识的吸收。感兴趣的同学可以先去试试，这里就不在累赘提供答案了。 欢迎探讨更多<code>Web安全</code>相关话题。</p><a id="more"></a><h3 id="插入执行标签"><a href="#插入执行标签" class="headerlink" title="插入执行标签"></a>插入执行标签</h3><ul><li>script</li><li>img onerror触发</li><li>iframe srcdoc触发</li></ul><h3 id="标签等提前闭合-截断"><a href="#标签等提前闭合-截断" class="headerlink" title="标签等提前闭合(截断)"></a>标签等提前闭合(截断)</h3><ul><li><p>如在<code>富文本</code>, <code>input</code>, <code>textarea</code>, 可编辑<code>div</code>等，对应xss-demo <a href="https://xss.haozi.me/#/0x01" target="_blank" rel="noopener">0x01</a>, <a href="https://xss.haozi.me/#/0x02" target="_blank" rel="noopener">0x02</a></p></li><li><p>style标签</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p>注释提前闭合<a href="https://xss.haozi.me/#/0x05" target="_blank" rel="noopener">0x05</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--!&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>input type重写<a href="https://xss.haozi.me/#/0x06" target="_blank" rel="noopener">0x06</a></p></li></ul><p>input的type，在type之前可以重写为image，通过<code>onerror</code>注入</p><h3 id="ES6-tag标签"><a href="#ES6-tag标签" class="headerlink" title="ES6 tag标签"></a>ES6 tag标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert`1`&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="转义字符仍可执行"><a href="#转义字符仍可执行" class="headerlink" title="转义字符仍可执行"></a>转义字符仍可执行</h3><ul><li>script标签可执行 <code>base64</code>的html代码片段</li><li>onerror可执行 转义为 html 10进制， 16进制的代码片段</li><li>url转义为 html 10进制， 16进制 仍可执行, url的定义可获取其他域下的资源文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</span><br></pre></td></tr></table></figure><h3 id="svg不闭合也执行"><a href="#svg不闭合也执行" class="headerlink" title="svg不闭合也执行"></a>svg不闭合也执行</h3><p>查看 <a href="https://xss.haozi.me/#/0x07" target="_blank" rel="noopener">0x07</a></p><h3 id="正则替换不靠谱"><a href="#正则替换不靠谱" class="headerlink" title="正则替换不靠谱"></a>正则替换不靠谱</h3><ul><li>正则替换 <a href="https://xss.haozi.me/#/0x0C" target="_blank" rel="noopener">0x0C</a></li><li>正则命中 <a href="https://xss.haozi.me/#/0x0E" target="_blank" rel="noopener">0x0E</a></li><li>//追加执行，正则替换失效 <a href="https://xss.haozi.me/#/0x0F" target="_blank" rel="noopener">0x0F</a></li></ul><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><ul><li><a href="https://imququ.com/post/web-security-and-response-header.html" target="_blank" rel="noopener">配置安全头</a></li><li><a href="http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-1/" target="_blank" rel="noopener">xss监控</a></li><li>服务端白名单过滤</li></ul><p>这样总结对我更好的理解，也明白为什么最后是通过替换不同的字符来做处理。 <code>Web安全</code>路很长，需要持续关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;朋友组织了一场&lt;code&gt;xss&lt;/code&gt; live，&lt;code&gt;安全&lt;/code&gt;一直是开发中不可忽视的一部分。而&lt;code&gt;xss&lt;/code&gt;作为web开发中最常见的攻击手段，防范是必然的。基于&lt;strong&gt;web浏览器tricks&lt;/strong&gt;，&lt;strong&gt;JavaScript的发展&lt;/strong&gt;，&lt;strong&gt;npm等开源项目漏洞&lt;/strong&gt;，&lt;strong&gt;web注入&lt;/strong&gt;等会让开发者越来越防不胜防。&lt;/p&gt;
&lt;p&gt;本次总结基于耗子的&lt;a href=&quot;https://github.com/haozime/xss-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xss-demo&lt;/a&gt;，以及自己对xss的理解和知识的吸收。感兴趣的同学可以先去试试，这里就不在累赘提供答案了。 欢迎探讨更多&lt;code&gt;Web安全&lt;/code&gt;相关话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="xss" scheme="https://imjiangtao.com/tags/xss/"/>
    
  </entry>
  
</feed>
